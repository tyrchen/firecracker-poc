# Firecracker POC

## 1. POC 目标与范围 (Goal & Scope)

* **核心功能:** 创建一个 Web 服务，提供单个 API 端点 `/execute`。
* **输入:** 该端点接收一个包含**待执行 Python 代码**的 JSON 对象。
  * *为什么是 Python？* 因为它是 AI/Agent 领域最常用的语言，且解释器易于集成。
* **处理流程:**
    1. 服务接收到请求。
    2. **动态**地启动一个全新的 Firecracker microVM。
    3. 将 Python 代码注入到 microVM 中执行。
    4. 捕获 microVM 的标准输出 (stdout) 和标准错误 (stderr)。
    5. 关闭并清理 microVM。
    6. 将执行结果返回给客户端。
* **技术选型:**
  * **语言:** Rust
  * **Web 框架:** `axum` (现代、模块化，与 `tokio` 生态完美集成)
  * **异步运行时:** `tokio`
  * **序列化/反序列化:** `serde`

## 2. 核心工作流 (Core Workflow)

1. **客户端 (`curl`)** 发送 `POST` 请求到 `http://localhost:3000/execute`，请求体为 `{"code": "print(2 + 2)"}`。
2. **`axum` Web 服务** 接收请求，解析出 Python 代码。
3. **Rust 逻辑层** 开始执行核心任务：
    a.  准备一个唯一的 Firecracker 配置文件（或使用模板）。
    b.  以一个子进程的形式启动 `firecracker` 可执行文件，并为其分配一个 API socket 文件 (例如 `/tmp/firecracker-UNIQUE_ID.socket`)。
    c.  通过该 socket 文件，使用 HTTP 客户端向 Firecracker 的 API 发送指令：
    i.  `PUT /machine-config`: 设置 vCPU 和内存。
    ii. `PUT /drives/rootfs`: 指定预先准备好的、包含 Python 环境的根文件系统 (`rootfs.ext4`)。
    iii. `PUT /boot-source`: 指定内核镜像 (`vmlinux`)。
    iv. `PUT /actions`: 发送 `InstanceStart` 指令，启动 VM。
    d.  VM 启动后，系统会初始化并最终等待输入。我们将用户的 Python 代码通过 VM 进程的**标准输入 (`stdin`)** 管道传入。
    e.  同时，我们监听 VM 进程的**标准输出 (`stdout`)** 和**标准错误 (`stderr`)** 来捕获执行结果。
4. 代码执行完毕（或超时），Rust 程序**终止** `firecracker` 子进程，相关的 socket 文件和资源被清理。
5. **`axum` 服务** 将捕获到的 `stdout` 和 `stderr` 包装成 JSON 格式，作为 HTTP 响应返回给客户端。

## 3. 分步实施指南 (Step-by-Step Guide)

### **步骤 1: 项目初始化**

```bash
cargo new firecracker-poc
cd firecracker-poc
```

在 `Cargo.toml` 中添加依赖:

```toml
[dependencies]
axum = "0.8"
tokio = { version = "1", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
reqwest = { version = "0.12", features = ["json"] } # 用于和 Firecracker API socket 通信
uuid = { version = "1", features = ["v4"] }
```

### **步骤 2: 设计数据结构**

`src/main.rs`:

```rust
use serde::{Deserialize, Serialize};

#[derive(Deserialize)]
struct ExecuteRequest {
    code: String,
}

#[derive(Serialize)]
struct ExecuteResponse {
    stdout: String,
    stderr: String,
    success: bool,
}
```

### **步骤 3: 核心逻辑 - 封装 Firecracker 交互**

我们可以创建一个 `runner.rs` 模块来处理这些脏活。核心是启动 `firecracker` 进程，然后通过 `reqwest` 的 `unix_socket` 功能与它通信。

**伪代码逻辑 (`src/runner.rs`):**

```rust
use std::process::{Command, Stdio};
use tokio::io::{AsyncWriteExt, AsyncReadExt};

// ... 你的 ExecuteResponse 和其他结构体

pub async fn run_in_vm(code: &str) -> Result<ExecuteResponse, anyhow::Error> {
    let vm_id = uuid::Uuid::new_v4().to_string();
    let socket_path = format!("/tmp/firecracker-{}.socket", vm_id);

    // 1. 启动 Firecracker 进程
    let mut firecracker_process = Command::new("firecracker")
        .arg("--api-sock")
        .arg(&socket_path)
        .stdin(Stdio::piped())   // 我们将通过这个 stdin 喂代码
        .stdout(Stdio::piped()) // 从这里读结果
        .stderr(Stdio::piped())
        .spawn()?;

    // 等待 socket 文件被创建...
    tokio::time::sleep(tokio::time::Duration::from_millis(50)).await;

    // 2. 配置并启动 VM (通过HTTP请求到socket)
    let client = reqwest::Client::new();
    let socket_url_base = format!("http://unix/{}", socket_path);

    // 设置内核
    client.put(format!("{}/boot-source", socket_url_base))
        .json(&serde_json::json!({
            "kernel_image_path": "./hello-vmlinux.bin",
            "boot_args": "console=ttyS0 reboot=k panic=1 pci=off"
        })).send().await?;

    // 设置根文件系统
    client.put(format!("{}/drives/rootfs", socket_url_base))
        .json(&serde_json::json!({
            "drive_id": "rootfs",
            "path_on_host": "./alpine-python.ext4",
            "is_root_device": true,
            "is_read_only": false
        })).send().await?;

    // 启动！
    client.put(format!("{}/actions", socket_url_base))
        .json(&serde_json::json!({"action_type": "InstanceStart"}))
        .send().await?;

    // 3. 注入代码并读取结果
    let mut vm_stdin = firecracker_process.stdin.take().unwrap();
    // VM 启动后会执行 /bin/sh, 我们让它执行 python
    let full_command = format!("python3 -c '{}'\n", code.replace("'", "\\'"));
    vm_stdin.write_all(full_command.as_bytes()).await?;

    // 关闭 stdin 以便 VM 知道输入结束
    drop(vm_stdin);

    // 读取输出
    let mut stdout_buf = Vec::new();
    let mut stderr_buf = Vec::new();
    let mut stdout_reader = firecracker_process.stdout.take().unwrap();
    let mut stderr_reader = firecracker_process.stderr.take().unwrap();

    stdout_reader.read_to_end(&mut stdout_buf).await?;
    stderr_reader.read_to_end(&mut stderr_buf).await?;

    // 4. 清理
    firecracker_process.kill().await?;

    let response = ExecuteResponse {
        stdout: String::from_utf8_lossy(&stdout_buf).to_string(),
        stderr: String::from_utf8_lossy(&stderr_buf).to_string(),
        success: true, // 可根据 stderr 是否为空判断
    };

    Ok(response)
}
```

*注意: 上述代码是伪代码和真实代码的结合，用于说明逻辑。实际实现需要更健壮的错误处理和异步操作。*

### **步骤 4: 编写 Web 服务 (`src/main.rs`)**

```rust
use axum::{routing::post, Json, Router};
use std::net::SocketAddr;

// ... 导入你的数据结构和 runner 模块

async fn execute_handler(Json(payload): Json<ExecuteRequest>) -> Json<ExecuteResponse> {
    // 调用我们的核心逻辑
    let result = runner::run_in_vm(&payload.code).await.unwrap_or_else(|e| {
        ExecuteResponse {
            stdout: String::new(),
            stderr: e.to_string(),
            success: false,
        }
    });
    Json(result)
}

#[tokio::main]
async fn main() {
    let app = Router::new().route("/execute", post(execute_handler));

    let addr = SocketAddr::from(([127, 0, 0, 1], 3000));
    println!("listening on {}", addr);

    let listener = tokio::net::TcpListener::bind(&addr).await.unwrap();
    axum::serve(listener, app).await.unwrap();
}
```

### **步骤 5: 运行和测试**

1. **运行服务:**

    ```bash
    cargo run
    ```

2. **打开另一个终端，使用 `curl` 测试:**

    ```bash
    curl -X POST \
      http://localhost:3000/execute \
      -H 'Content-Type: application/json' \
      -d '{
        "code": "import sys; import os; print(f\"Hello from a very secure VM! Python version: {sys.version}\"); print(f\"Current user: {os.geteuid()}\")"
      }'
    ```

3. **预期输出:**

    ```json
    {
      "stdout": "Hello from a very secure VM! Python version: 3.x.x ...\nCurrent user: 0\n",
      "stderr": "",
      "success": true
    }
    ```

-----

## 从 POC 到产品 (Next Steps)

这个 POC 证明了核心路径。要产品化，你还需要解决：

* **VM 池化:** 预先启动一组“温”VM 到达`InstanceStart`之前的状态，可以极大缩短响应时间。
* **异步任务:** 对于长任务，API 应立即返回一个任务ID，客户端稍后查询结果。
* **安全性增强:** 使用 `jailer` 来进一步限制 `firecracker` 进程的权限；为 VM 配置网络，只允许访问特定资源；设置更严格的 CPU 和内存限制。
* **健壮性:** 更完善的错误处理、超时机制和资源清理。

这个 POC 设计为你提供了一个坚实的起点，让你能亲手体验到用 Rust 和 Firecracker 构建下一代安全计算服务的强大与乐趣。
